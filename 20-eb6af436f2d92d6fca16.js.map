{"version":3,"file":"20-eb6af436f2d92d6fca16.js","mappings":"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","sources":["webpack://yuheiono.com/./node_modules/react-use/esm/misc/util.js","webpack://yuheiono.com/./node_modules/react-use/esm/useEvent.js","webpack://yuheiono.com/./node_modules/react-use/esm/useKey.js","webpack://yuheiono.com/./node_modules/react-swipeable/es/index.js","webpack://yuheiono.com/./src/components/mainvisual.tsx"],"sourcesContent":["export var noop = function () { };\nexport function on(obj) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (obj && obj.addEventListener) {\n        obj.addEventListener.apply(obj, args);\n    }\n}\nexport function off(obj) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (obj && obj.removeEventListener) {\n        obj.removeEventListener.apply(obj, args);\n    }\n}\nexport var isBrowser = typeof window !== 'undefined';\nexport var isNavigator = typeof navigator !== 'undefined';\n","import { useEffect } from 'react';\nimport { isBrowser, off, on } from './misc/util';\nvar defaultTarget = isBrowser ? window : null;\nvar isListenerType1 = function (target) {\n    return !!target.addEventListener;\n};\nvar isListenerType2 = function (target) {\n    return !!target.on;\n};\nvar useEvent = function (name, handler, target, options) {\n    if (target === void 0) { target = defaultTarget; }\n    useEffect(function () {\n        if (!handler) {\n            return;\n        }\n        if (!target) {\n            return;\n        }\n        if (isListenerType1(target)) {\n            on(target, name, handler, options);\n        }\n        else if (isListenerType2(target)) {\n            target.on(name, handler, options);\n        }\n        return function () {\n            if (isListenerType1(target)) {\n                off(target, name, handler, options);\n            }\n            else if (isListenerType2(target)) {\n                target.off(name, handler, options);\n            }\n        };\n    }, [name, handler, target, JSON.stringify(options)]);\n};\nexport default useEvent;\n","import { useMemo } from 'react';\nimport useEvent from './useEvent';\nimport { noop } from './misc/util';\nvar createKeyPredicate = function (keyFilter) {\n    return typeof keyFilter === 'function'\n        ? keyFilter\n        : typeof keyFilter === 'string'\n            ? function (event) { return event.key === keyFilter; }\n            : keyFilter\n                ? function () { return true; }\n                : function () { return false; };\n};\nvar useKey = function (key, fn, opts, deps) {\n    if (fn === void 0) { fn = noop; }\n    if (opts === void 0) { opts = {}; }\n    if (deps === void 0) { deps = [key]; }\n    var _a = opts.event, event = _a === void 0 ? 'keydown' : _a, target = opts.target, options = opts.options;\n    var useMemoHandler = useMemo(function () {\n        var predicate = createKeyPredicate(key);\n        var handler = function (handlerEvent) {\n            if (predicate(handlerEvent)) {\n                return fn(handlerEvent);\n            }\n        };\n        return handler;\n    }, deps);\n    useEvent(event, useMemoHandler, target, options);\n};\nexport default useKey;\n","import * as React from 'react';\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = React.useRef(Object.assign({}, initialState));\n    const transientProps = React.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = React.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = React.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react';\nimport { useKey } from 'react-use';\nimport { useSwipeable } from 'react-swipeable';\nimport { GatsbyImage, getImage } from 'gatsby-plugin-image';\nimport Box from '@mui/material/Box';\nimport { Link } from './common/link';\n\nconst Mainvisual = (data: any): React.JSX.Element => {\n  const img = data.images.edges;\n\n  const containerRef = React.useRef(null);\n  const [clientHeight, setClientHeight] = React.useState<number>(0);\n  const [current, setCurrent] = React.useState<number>(\n    Math.floor(Math.random() * img.length)\n  );\n  const [opacity, setOpacity] = React.useState<number>(0);\n  const isLockRequest = React.useRef<boolean>(true);\n  const transitionDuration: number = 1000;\n  const showingTime: number = 3500;\n\n  const sleep = (msec: number) =>\n    new Promise(resolve => setTimeout(resolve, msec));\n\n  const prev = () =>\n    setCurrent(current => (current - 1 + img.length) % img.length);\n  const next = () => setCurrent(current => (current + 1) % img.length);\n\n  const autoShowNext = async () => {\n    if (isLockRequest.current) return;\n\n    setOpacity(0);\n\n    await sleep(transitionDuration);\n    if (isLockRequest.current) return;\n\n    next();\n    setOpacity(1);\n\n    await sleep(transitionDuration);\n    if (isLockRequest.current) return;\n\n    await sleep(showingTime);\n    if (isLockRequest.current) return;\n\n    autoShowNext();\n  };\n\n  const requestShow = async ({ isPrev = false }) => {\n    if (isLockRequest.current) return;\n    isLockRequest.current = true;\n\n    setOpacity(0);\n    await sleep(transitionDuration);\n    isPrev ? prev() : next();\n    setOpacity(1);\n\n    await sleep(transitionDuration / 2);\n    isLockRequest.current = false;\n    await sleep(transitionDuration / 2);\n    if (isLockRequest.current) return;\n\n    if (isLockRequest.current) return;\n    await sleep(showingTime);\n    if (isLockRequest.current) return;\n\n    autoShowNext();\n  };\n\n  const requestShowPrev = async () => await requestShow({ isPrev: true });\n  const requestShowNext = async () => await requestShow({ isPrev: false });\n\n  useKey('ArrowLeft', requestShowPrev);\n  useKey('ArrowUp', requestShowPrev);\n  useKey('ArrowRight', requestShowNext);\n  useKey('ArrowDown', requestShowNext);\n\n  const handlers = useSwipeable({\n    onSwipedRight: () => requestShowPrev(),\n    onSwipedLeft: () => requestShowNext()\n  });\n\n  React.useEffect(() => {\n    const f = async () => {\n      setOpacity(1);\n      isLockRequest.current = false;\n      autoShowNext();\n      await sleep(transitionDuration + showingTime);\n    };\n\n    f();\n  }, []);\n\n  React.useEffect(() => {\n    const update = () => {\n      const imageData = getImage(img[current].node);\n      if (!imageData) return;\n\n      const { width, height } = imageData;\n\n      const aspectRatio = width / height;\n\n      // ヘッダーの2倍を引き適切なアスペクト比に\n      const newWidth = (clientHeight - 160) * aspectRatio;\n      (containerRef.current as any).style.width = newWidth + 'px';\n    };\n\n    const updateClientHeight = () => {\n      setClientHeight(document.documentElement.clientHeight);\n    };\n\n    window.addEventListener('resize', updateClientHeight);\n    window.addEventListener('load', updateClientHeight);\n\n    updateClientHeight();\n    update();\n\n    return () => {\n      window.removeEventListener('resize', updateClientHeight);\n      window.removeEventListener('load', updateClientHeight);\n    };\n  }, [img, current, clientHeight]);\n\n  const [, _link] = img[current].node.relativePath.match(\n    // @NOTE 2023.06.11 順番を柔軟に変更するためファイル名チェックを外す\n    // /^mainvisuals\\/\\d{2}_(.+)\\.(.+)$/\n    /^mainvisuals\\/.+_(.+)\\..+$/\n  );\n\n  const currentImageData = getImage(img[current].node);\n  const nextImageData = getImage(img[(current + 1) % img.length].node);\n\n  return (\n    <Box\n      component='section'\n      sx={{\n        position: 'relative',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        width: '100%',\n        mt: 10,\n        height: 'calc(100vh - 160px)'\n        // eslint-disable-next-line no-dupe-keys\n        // height: 'calc(100dvh - 160px)'\n      }}\n    >\n      <Box\n        ref={containerRef}\n        sx={{\n          position: 'relative',\n          height: '100%',\n          overflow: 'hidden'\n        }}\n      >\n        <Box\n          {...handlers}\n          sx={{\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center',\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            zIndex: 5,\n            transitionProperty: 'opacity',\n            transitionTimingFunction: 'ease-out',\n            transitionDuration: `${transitionDuration}ms`,\n            opacity\n          }}\n        >\n          <Link href={`/works/${_link}/`}>\n            {currentImageData && (\n              <GatsbyImage\n                image={currentImageData}\n                alt='YUHEI ONO'\n                // layout='fullWidth'\n                // placeholder='blurred'\n                style={{\n                  pointerEvents: 'none',\n                  userSelect: 'none'\n                }}\n              />\n            )}\n          </Link>\n        </Box>\n        <Box\n          sx={{\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center',\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            zIndex: -1\n          }}\n        >\n          {nextImageData && (\n            <GatsbyImage\n              image={nextImageData}\n              alt='preload'\n              // layout='fullWidth'\n              style={{\n                opacity: 0,\n                visibility: 'hidden',\n                pointerEvents: 'none',\n                userSelect: 'none'\n              }}\n            />\n          )}\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nexport default Mainvisual;\n"],"names":["noop","isBrowser","window","defaultTarget","isListenerType1","target","addEventListener","isListenerType2","on","name","handler","options","useEffect","obj","args","_i","arguments","length","apply","removeEventListener","off","JSON","stringify","key","fn","opts","deps","_a","event","useMemoHandler","useMemo","keyFilter","predicate","handlerEvent","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","cos","sin","getHandlers","set","handlerProps","onStart","isTouch","touches","state","props","document","onMove","onUp","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","slice","timeStamp","x","y","deltaX","deltaY","absX","abs","absY","time","velocity","sqrt","vxvy","dir","getDirection","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","e","attachTouch","el","cleanup","baseOptions","tls","forEach","h","o","output","ref","addState","cleanUpTouch","onMouseDown","useSwipeable","transientState","transientProps","previousProps","current","defaultKey","handlers","stateSetter","undefined","updateTransientState","data","img","images","edges","containerRef","React","clientHeight","setClientHeight","setCurrent","floor","random","opacity","setOpacity","isLockRequest","transitionDuration","showingTime","sleep","msec","Promise","resolve","setTimeout","next","autoShowNext","async","requestShow","isPrev","_ref","requestShowPrev","requestShowNext","useKey","onSwipedRight","onSwipedLeft","f","updateClientHeight","documentElement","update","imageData","getImage","node","width","height","newWidth","style","_link","relativePath","match","currentImageData","nextImageData","___EmotionJSX","Box","component","sx","position","display","justifyContent","alignItems","mt","overflow","_extends","top","left","zIndex","transitionProperty","transitionTimingFunction","Link","href","GatsbyImage","image","alt","pointerEvents","userSelect","visibility"],"sourceRoot":""}